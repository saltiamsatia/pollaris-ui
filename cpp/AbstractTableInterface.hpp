#pragma once

#include <Dnmx.hpp>

#include <QObject>
#include <QJSValue>
#include <QDateTime>
#include <QNetworkReply>
#include <QAbstractListModel>

class BlockchainInterface;

//! \brief An entry in the database journal, declaring a change in one of the other tables
struct JournalEntry {
    uint64_t id;
    QDateTime timestamp;
    QString table;
    uint64_t scope;
    uint64_t key;
    enum EntryType {
        AddRow,
        DeleteRow,
        ModifyRow
    } type;

    JournalEntry() {}
    JournalEntry(QJsonObject json);
    static QList<JournalEntry> fromJsonArray(QJsonArray array);

    bool isValid() const { return !timestamp.isNull(); }

    bool operator==(const JournalEntry& other) const {
        return std::tie(id, timestamp, table, scope, key, type) ==
                std::tie(other.id, other.timestamp, other.table, other.scope, other.key, other.type);
    }
    bool operator!=(const JournalEntry& other) const { return !(*this == other); }
};

/*!
 * \brief A polymorphic interface connecting the table types to the Qt/QML object system
 *
 * The actual tables are generated by instantiating a template table class (AbstractTable) with the various fields
 * stored in that table. The QObject system, however, is not compatible with templates, and cannot support signals
 * and slots and connections to a template class. It is compatible, however, with polymorphic interface classes, so
 * this class defines a polymorphic interface which is implemented by the table template, and thus provides an
 * adaptor allowing Qt to interface with the table template.
 */
class AbstractTableInterface : public QObject {
    Q_OBJECT
    ADD_DNMX

    //! \property tableName The name of the record type the table stores
    Q_PROPERTY(QString tableName READ tableName CONSTANT)
    //! \property tableScope The scope of the table
    Q_PROPERTY(QVariant tableScope READ tableScope NOTIFY scopeChanged)
    //! \property hasPendingEdits True if the table has edits in a Pending state; false otherwise
    Q_PROPERTY(bool hasPendingEdits READ hasPendingEdits NOTIFY hasPendingEditsChanged)
    //! \property baseDraftID The lowest ID number used for draft IDs; all IDs greater or equal to this are Draft IDs
    Q_PROPERTY(quint64 baseDraftId READ baseDraftId CONSTANT)

protected:
    bool pendingEdits = false;
    BlockchainInterface* blockchain;
    QString scope;

public:
    explicit AbstractTableInterface(BlockchainInterface* blockchain, QString scope);
    virtual ~AbstractTableInterface() {}

    constexpr static uint64_t BASE_DRAFT_ID = 1'000'000'000'000;
    constexpr static const char* LOAD_STATE_ROLE_NAME = "loadState";

    quint64 baseDraftId() const { return BASE_DRAFT_ID; }

    virtual QString tableName() const = 0;
    virtual QVariant tableScope() const { return scope; }
    virtual bool hasPendingEdits() const = 0;

    Q_INVOKABLE virtual QAbstractListModel* allRows() = 0;
    Q_INVOKABLE virtual QJSValue findRowIf(QJSValue predicate) const = 0;
    Q_INVOKABLE virtual QVariantMap getRow(QVariant id) const = 0;
    Q_INVOKABLE virtual QVariantList localRows() const = 0;

    BlockchainInterface* getBlockchain() const { return blockchain; }

public slots:
    virtual void fullRefresh() = 0;
    virtual void processJournal(QList<JournalEntry> entries) = 0;

    /*!
     * \brief Make edits to a row, marking the row state as Draft
     * \param rowId The ID of the row to edit
     * \param changeMap A map of field names to edit to their new values
     *
     * Edits the fields of a row, and sets the state to DraftState, unless the state was previously DraftAdd. Neither
     * the ID field, nor virtual fields can be edited.
     *
     * If the edited row's state is DraftDelete, or if the table has pending edits, the edit will fail.
     */
    virtual void draftEditRow(QVariant rowId, QVariantMap changeMap) = 0;
    /*!
     * \brief Make a draft edit adding a new row
     * \param fieldMap The fields of the row, excluding virtual fields
     *
     * Adds a new row to the table with the DraftAdd state. The new row will be displayed by models that accept it.
     *
     * If the table has a numeric ID, the new row will be assigned an ID. If the fieldMap specifies a numeric ID, the
     * edit will fail. If the table has a string ID, the fieldMap must specify a unique ID, or the edit will fail.
     *
     * If, after new rows are placed in the PendingAdd state, a new row is received from the backend and that row's
     * values match those of a pending row, the rows will be assumed to be a match and the pending new row will be
     * removed and the \ref pendingEditSettled signal will be emitted.
     *
     * If the table has pending edits, the edit will fail.
     */
    virtual void draftAddRow(QVariantMap fieldMap) = 0;
    /*!
     * \brief Make a draft edit deleting a row
     * \param rowId The ID of the row to delete
     *
     * Sets a row in the table to PendingDelete state. If the table has pending edits, the edit will fail.
     */
    virtual void draftDeleteRow(QVariant rowId) = 0;
    //! \brief Update all edits in this table to a Pending status instead of Draft. If table already has Pending
    //! edits, this function does nothing.
    virtual void markEditsPending() = 0;
    //! \brief Revert all edits in this table, draft or pending, to the real database state
    virtual void resetEdits() = 0;

    void setBlockchain(BlockchainInterface* blockchain) {
        if (this->blockchain != blockchain)
            emit blockchainChanged(this->blockchain = blockchain);
    }

signals:
    //! \brief Emitted to notify that the table's scope has changed.
    //!
    //! This signal notifies that the table's scope has changed. In general, once the table is created, the scope it
    //! tracks will never change; however, there is one case where it does. If the table is created speculatively to
    //! display draft edits of a table that has not been created in the database yet, then its scope will be based on
    //! a draft ID number, and when the table is resolved to a new table in the database, its scope will change.
    void scopeChanged(QVariant tableScope);

    /*!
     * \brief Emitted whenever an update from the backend overwrites a local Draft edit
     * \param rowId The row that had been edited and got invalidated
     *
     * This signal notifies that a Draft edit was invalidated by changes in the backend database. It is emitted
     * whenever a change in the journal triggers a row to be updated, and the update overwrites an edited row.
     *
     * When this signal is emitted, the affected row and status will have been reverted back to the database state,
     * but other edited rows will still contain their edits.
     *
     * Note that while this signal generally applies only to Draft edits, it will also be emitted if a row from the
     * server overwrites a PendingDelete row.
     */
    void draftEditInvalidated(QVariant rowId);

    /*!
     * \brief Emitted whenever an update from the backend overwrites a row with a pending edit
     * \param pendingRow The local, edited row value
     * \param settledRow The settled row value from the backend
     *
     * This signal notifies that a journal update triggered a reload of a row with Pending edits.
     *
     * In the ideal case, for rows which were added or modified, the update results in pendingRow and settledRow will
     * match exactly, as the Pending edits are a prediction of the settled row's value. If they do not match, it
     * likely indicates that the prediction was incorrect due to a bug, but it is also possible that a transaction
     * race caused the row to be modified by some other transaction while we were waiting for our transaction to be
     * settled.
     *
     * If the row was added, pendingRow will be the fieldMap from draftAddRow. If the row was deleted, settledRow
     * will be {"deleted": true}
     */
    void pendingEditSettled(QVariantMap pendingRow, QVariantMap settledRow);

    void hasPendingEditsChanged(bool hasPendingEdits);
    void blockchainChanged(BlockchainInterface* blockchain);
};

/*!
 * \typedef ApiCallback
 *
 * A type definition for a function with the following signature:
 * \code
 *      QNetworkReply* ApiCallback(QString, QByteArray);
 * \endcode
 *
 * Used to describe a callback function which calls the provided API function with the provided JSON argument object.
 * The callback returns a pointer to the \ref QNetworkReply corresponding to the API call.
 */
using ApiCallback = std::function<QNetworkReply*(QString, QByteArray)>;
